; MAP CHANGER from level data file

LEVEL	QUERY	"What Level :
ST_LEVEL	EQU	LEVEL
PDS		EQU	1	; pds code there

TABLELO	MACRO			; FOR A= @2 TO @3 ; VALUE = A*@4+@5
value	= @2
@1	DO			; Define Lable
	DL ((value*@4)+@5)	; Low Byte
value	= value + 1
	UNTIL value > @3
	ENDM

TABLEHI	MACRO			; FOR A= @2 TO @3 ; VALUE = A*@45
value	= @2
@1	DO			; Define Lable
	DH ((value*@4)+@5)
value	= value + 1
	UNTIL value > @3
	ENDM

NOB	MACRO
	DB	&24		; BIT xx
	ENDM

NOW	MACRO
	DB	&2C		; BIT xx xx
	ENDM

ZP	MACRO
@1	EQU	VARS
VARS	= VARS+@2
	ENDM

START_TOP_Y	EQU	50
XMAP_STOP	EQU	0

VARS	=	1

	ZP	R6510,1		; I/O PORT

	ZP	IRQSAVEA,1
	ZP	IRQSAVEX,1
	ZP	IRQSAVEY,1
	
	ZP	XOFFSET,1		; X offset into map tile positions
	ZP	XOFFTEMP,1		; temp for above used in plot down
	ZP	YOFFSET,1		; Y offset into map tile positions
	ZP	XOFFOLD,1		; last value
	ZP	YOFFOLD,1		; last value
	ZP	SCREEN,2
	ZP	COLOUR,2
	ZP	MAPMEM,2
	ZP	CURSOR_X,1		; screen cords of tile
	ZP	CURSOR_Y,1		; as above but in y

	; reading of input devices
	ZP	MOVE,1
	ZP	LAST_MOVE,1
	ZP	JOY,1
	ZP	SYNC,1
	ZP	LEFT,1
	ZP	RIGHT,1
	ZP	UP,1
	ZP	DOWN,1
	ZP	FIRE,1
	ZP	BYTE,1
	ZP	KEYBYTE,8		; all maxrix store
	ZP	DISPLAY,1		; see what on screen (0 map 255 tiles)
	; general temp zero page and subroutine paramaters zero page
	ZP	MIKE1,2
	ZP	MIKE2,2
	ZP	XTEMP,1
	ZP	YTEMP,1
	ZP	TEMP,1
	ZP	SPEED,1
	ZP	TEMP1,2
	ZP	XSIZE,1		; blocks in x
	ZP 	YSIZE,1		; blocks in y
	ZP	TILE_YPOS,1
	ZP	TILE_XPOS,1

	ZP	MAP_MEM0,2
	ZP	MAP_MEM1,2
	ZP	MAP_MEM2,2
	ZP	MAP_MEM3,2
	ZP	MAP_MEM4,2
	ZP	MAP_MEM5,2

TCHARSET	EQU	&B800		; title page character set
SCREEN1	EQU	&0400		; game SCREEN1
CHARSET	EQU	&0800		; game char set

	INCLUDE	..\CODE\C64.PDS

PSPRITES	EQU	&0200
	ORG	PSPRITES

	HEX	F00F00
	HEX	800100
	HEX	800100
	HEX	800100
	HEX	000000
	HEX	000000
	HEX	000000
	HEX	000000
	HEX	000000
	HEX	000000
	HEX	000000
	HEX	000000
	HEX	800100
	HEX	800100
	HEX	800100
	HEX	F00F00
	HEX	000000
	HEX	000000
	HEX	000000
	HEX	000000
	HEX	000000
	HEX	18
	DS	64*7,0
	
PSP_POINT	EQU	PSPRITES/64

	INCLUDE	BLOCK.PDS

	INCLUDE	..\CODE\LEVDAT.PDS

PLOT_Y	EQU	8;	10	; max plot tiles down screen

	ORG	&1000

BOTY	EQU	PLOT_Y-1
LEFTX	EQU	0
RIGHTX	EQU	19

START_CODE	LDA	#%00011011
	STA	VICCR1
	LDA	#%00011000
	STA	VICCR2
	LDA	#%00010010
	STA	VICMCR
	LDA	C1
	STA	COLOUR1
	LDA	C2
	STA	COLOUR2
	LDA	#0
	STA	COLOUR3
	STA	MULTICOL
	STA	CURSOR_X
	STA	CURSOR_Y
	STA	BYTE
	STA	XOFFSET
	STA	YOFFSET
	STA	XOFFOLD
	STA	YOFFOLD
	STA	DISPLAY		; show map first
	STA	BORDER
	STA	COLOUR0

	LDY	#200
!CLS	STA	SCREEN1+(0*200)-1,Y
	STA	SCREEN1+(1*200)-1,Y
	STA	SCREEN1+(2*200)-1,Y
	STA	SCREEN1+(3*200)-1,Y
	STA	SCREEN1+(4*200)-1,Y
	DEY
	BNE	!CLS	
	LDA	#50+(8*24)
	STA	Y1
	STA	Y2
	STA	Y3
	STA	Y4
	STA	Y5
	STA	Y6
	STA	Y7
	LDA	#100
	STA	X1
	LDA	#100+24
	STA	X2
	LDA	#100+24+24
	STA	X3
	LDA	#100+24+24+24
	STA	X4
	LDA	#100+24+24+24+24
	STA	X5
	LDA	#100+24+24+24+24+24
	STA	X6
	LDA	#100+24+24+24+24+24+24
	STA	X7
	LDA	#1
	STA	SPC1
	STA	SPC2
	STA	SPC3
	STA	SPC4
	STA	SPC5
	STA	SPC6
	STA	SPC7

	LDA	#255
	STA	KEYBYTE+0
	STA	KEYBYTE+1	
	STA	KEYBYTE+2
	STA	KEYBYTE+3
	STA	KEYBYTE+4
	STA	KEYBYTE+5
	STA	KEYBYTE+6
	STA	KEYBYTE+7

	;STA	TILE_TL
	;STA	TILE_TR
	;STA	TILE_BL
	;STA	TILE_BR
	LDA	#1
	;STA	TCOL_TL
	;STA	TCOL_TR
	;STA	TCOL_BL
	;STA	TCOL_BR

	LDA	#255
	STA	CHARSET+(255*8)+0
	STA	CHARSET+(255*8)+1
	STA	CHARSET+(255*8)+2	
	STA	CHARSET+(255*8)+3
	STA	CHARSET+(255*8)+4
	STA	CHARSET+(255*8)+5
	STA	CHARSET+(255*8)+6
	STA	CHARSET+(255*8)+7

	STA	TILE_TL+248
	STA	TILE_TL+249
	STA	TILE_TL+250
	STA	TILE_TL+251
	STA	TILE_TL+252
	STA	TILE_TL+253
	STA	TILE_TL+254
	STA	TILE_TL+255

	STA	TILE_TR+248
	STA	TILE_TR+249
	STA	TILE_TR+250
	STA	TILE_TR+251
	STA	TILE_TR+252
	STA	TILE_TR+253
	STA	TILE_TR+254
	STA	TILE_TR+255

	STA	TILE_BL+248
	STA	TILE_BL+249
	STA	TILE_BL+250
	STA	TILE_BL+251
	STA	TILE_BL+252
	STA	TILE_BL+253
	STA	TILE_BL+254
	STA	TILE_BL+255

	STA	TILE_BR+248
	STA	TILE_BR+249
	STA	TILE_BR+250
	STA	TILE_BR+251
	STA	TILE_BR+252
	STA	TILE_BR+253
	STA	TILE_BR+254
	STA	TILE_BR+255

	LDY	#1
	LDX	#248
POKECOL	TYA
	STA	TCOL_TL,X
	STA	TCOL_TR,X
	STA	TCOL_BL,X
	STA	TCOL_BR,X
	INY
	INX
	BNE	POKECOL	

	LDA	#PSP_POINT
	STA	SPRITE0
	LDA	#PSP_POINT+1
	STA	SPRITE1
	LDA	#PSP_POINT+2
	STA	SPRITE2
	LDA	#PSP_POINT+3
	STA	SPRITE3
	LDA	#PSP_POINT+4
	STA	SPRITE4
	LDA	#PSP_POINT+5
	STA	SPRITE5
	LDA	#PSP_POINT+6
	STA	SPRITE6
	LDA	#PSP_POINT+7
	STA	SPRITE7
	LDA	#255
	STA	ENABLE

	LDA	SIZEX		; init sizes
	STA	XSIZE
	LDA	SIZEY
	STA	YSIZE
	JSR	MAKE_MAP_MEM

	JSR	PDSSETUP
	JSR	SETIRQ

	;JSR	SET_PICKUPS		; show pickup items
	;JSR	SHOW_RESCUE		; show where prisoners are
	JSR	ALLSCREEN
	JSR	SHOW_TILES
	
FOREVER	LDA	#%00000010		; P
	BIT	KEYBYTE+5
	BNE	DYSAN
	JSR	SET_PICKUPS		; toggle them
DYSAN	LDA	#%00100000		; H
	BIT	KEYBYTE+3
	BNE	MUSIC
	JSR	DELETE_HORIZONTAL
	LDX	#3
	LDY	#15
	LDA	#%00100000
	JSR	DE_BOUNCE
MUSIC	LDA	#%10000000			; V
	BIT	KEYBYTE+3
	BNE	SCORE
	JSR	DELETE_VERTICAL
	LDX	#3
	LDY	#15
	LDA	#%10000000
	JSR	DE_BOUNCE

SCORE	LDA	#%00010000			; C
	BIT	KEYBYTE+2
	BNE	HOUSE
	LDA	MAPMEM+1
	SEC
	SBC	#<MAP_START-OTHER_MAP
	STA	MAPMEM+1
	LDY	#0
	LDA	(MAPMEM),Y
	PHA
	LDA	MAPMEM+1
	CLC
	ADC	#<MAP_START-OTHER_MAP
	STA	MAPMEM+1
	PLA
	STA	(MAPMEM),Y

HOUSE	LDA	#%01000000		; T key
	BIT	KEYBYTE+2
	BNE	MELBOR
	JSR	PLOT_CONTROL	; tunnel control parts
MELBOR	LDA	#%00000100		; CTRL key
	BIT	KEYBYTE+7
	BNE	PEACH
	JSR	HIDE_CONTROL	; hide unhide tunnels
	LDA	#%00000100
	LDX	#7
	LDY	#50
	JSR	DE_BOUNCE
PEACH	LDA	#%01000000			; O
	BIT	KEYBYTE+4
	BNE	PLUM
	JSR	CLOSE_DOORS
	LDA	#%01000000
	LDX	#4
	LDY	#25
	JSR	DE_BOUNCE
	; map change in xsize 
PLUM	LDA	#%10000000
	BIT	KEYBYTE+2
	BNE	AVACADO

	; press X key now check for SHIFT
	LDA	#%10000000
	BIT	KEYBYTE+1		; left shift
	BEQ	DOWNTHEN		; yes SHIFT X minus in X
	LDA	#%00010000
	BIT	KEYBYTE+6		; right shift
	BEQ	DOWNTHEN		; yes SHIFT X minus in X
	; otherwise advance xsize
	LDA	XSIZE
	CMP	#255		; silly maxium (maybe not so) 
	BEQ	AVACADO
	INC	XSIZE		; advance by 1
	JMP	DOIT

DOWNTHEN	LDA	XSIZE
	CMP	#20		; smallest is screen size
	BEQ	AVACADO		; no change
	DEC	XSIZE
	LDA	#0
	STA	XOFFSET
	STA	YOFFSET
DOIT	JSR	MAKE_MAP_MEM
	LDX	#2		; X key
	LDY	#5
	LDA	#%10000000
	JSR	DE_BOUNCE

AVACADO	; map change in ysize 
	LDA	#%00000010
	BIT	KEYBYTE+3
	BNE	PEAR
	; press X key now check for SHIFT
	LDA	#%10000000
	BIT	KEYBYTE+1		; left shift
	BEQ	DOWNTHEN1		; yes SHIFT X minus in X
	LDA	#%00010000
	BIT	KEYBYTE+6		; right shift
	BEQ	DOWNTHEN1		; yes SHIFT X minus in X
	; otherwise advance xsize
	LDA	YSIZE
	CMP	#128		; silly maxium (maybe not so) 
	BEQ	PEAR
	INC	YSIZE		; advance by 1
	JSR	MAKE_MAP_MEM
	JMP	PEARL

DOWNTHEN1	LDA	YSIZE
	CMP	#PLOT_Y		; smallest is screen size
	BEQ	AVACADO		; no change
	JSR	LOOSE_LINE
PEARL	LDA	#%00000010
	LDX   #3
	LDY	#5
	JSR	DE_BOUNCE

PEAR	LDA	#%00100000
	BIT	KEYBYTE+5		; : key
	BNE	NOADV
	DEC	BYTE		;
	JSR	SHOW_TILES		; repaint them
NOADV	LDA	#%00000100
	BIT	KEYBYTE+6
	BNE	NOADV1
	INC	BYTE
	JSR	SHOW_TILES
NOADV1
	LDA	#%00010000		; F1
	BIT	KEYBYTE+0
	BNE	NOF1
	JSR	GRAB_FIRST
NOF1	LDA	#%00100000		; F3
	BIT	KEYBYTE+0
	BNE	NOF3
	JSR	GRAB_SECOND
NOF3	LDA	#%00001000		; F7
	BIT	KEYBYTE+0
	BNE	NOF7		
	JSR	REPLOT_DATA
NOF7	LDA	#%00100000		; CBM
	BIT	KEYBYTE+7
	BNE	NOCBM
	JSR	SWAP_MAP

NOCBM	LDA	#%00100000		; S
	BIT	KEYBYTE+1
	BNE	NOSK
	JSR	CHANGE		; physical map change
	
NOSK	LDA	FIRE
	BEQ	SPCB
	LDA	BYTE
	LDY	#0
	STA	(MAPMEM),Y

SPCB	LDA	#%00010000		; space bar
	BIT	KEYBYTE+7
	BNE	NOSP_AR
	LDY	#0
	LDA	(MAPMEM),Y
	STA	BYTE
	JSR	SHOW_TILES
	
NOSP_AR	; Normal stuff
	LDA	#%00000001		; +
	BIT	KEYBYTE+5
	BNE	MIN
	LDY	#0
	LDA	(MAPMEM),Y
	CLC
	ADC	#1
	STA	(MAPMEM),Y
	LDX	#5		; key offset
	LDA	#1		; bit test
	JSR	LET_KEY_GO
	JMP	NOAD
	
MIN	LDA	#%00001000		; -
	BIT	KEYBYTE+5
	BNE	NOAD
	LDY	#0
	LDA	(MAPMEM),Y
	SEC
	SBC	#1
	STA	(MAPMEM),Y
	LDX	#5		; key offset
	LDA	#8		; bit test
	JSR	LET_KEY_GO

NOAD	LDA	#%00000100		; Cursor key Left/Right
	BIT	KEYBYTE+0
	BNE	NOCH
	LDA	#%00010000		; Right Shift
	BIT	KEYBYTE+6
	BEQ	MOVE_TIL
	LDA	#%10000000		; Left Shift
	BIT	KEYBYTE+1
	BEQ	MOVE_TIL
	BNE	SMAL
		
NOCH	LDA	RIGHT		; move right
	BEQ	ALEFT		; no

	LDA	XOFFSET
RIGHT1	CMP	#255		;SIZEX-20
	BNE	PRUB
	LDA	CURSOR_X
	CMP	#19
	BCS	ALEFT
	BCC	ADDME1
PRUB	LDA	CURSOR_X		; at edge
	CMP	#RIGHTX		; yes
	BEQ	SMAL
ADDME1	ADC	#1
	STA	CURSOR_X
	JMP	ALEFT

SMAL	LDA	XOFFSET		; map tile at right edge
RIGHT2	CMP	#255		; SIZEX-20
	BCS	ALEFT		; yes
	ADC	#1		; else move one on
	STA	XOFFSET
			
ALEFT	LDA	LEFT		; move left
	BEQ	NOMOVE		; no
	LDA	XOFFSET
	BNE	PRUB2
	LDA	CURSOR_X
	BEQ	NOMOVE
	BNE	SUBME1
PRUB2	LDA	CURSOR_X
	CMP	#LEFTX
	BEQ	MOVE_TIL		; at left already
SUBME1	SEC
	SBC	#1		; back 1
	STA	CURSOR_X
	JMP	NOMOVE

MOVE_TIL	LDA	XOFFSET		; map pos at left edge
	BEQ	NOMOVE		; yes
	SEC
	SBC	#1		; else back 1
	STA	XOFFSET

NOMOVE	LDA	#%10000000		; cursor key up & down
	BIT	KEYBYTE+0
	BNE	NOTU
	LDA	#%00010000		; Right Shift
	BIT	KEYBYTE+6
	BEQ	TILP
	LDA	#%10000000		; Left Shift
	BIT	KEYBYTE+1
	BNE	TILP1
	BEQ	TILP

NOTU	LDA	UP		; move up
	BEQ	TRDO		; no

	LDA	YOFFSET
	BNE	CANDY
	LDA	CURSOR_Y
	BEQ	TRDO
	BNE	SUBME2
CANDY	LDA	CURSOR_Y		; top already
	BEQ	TILP
SUBME2	SEC			; else - 1
	SBC	#1
	STA	CURSOR_Y
	JMP	TRDO
TILP	LDA	YOFFSET		; top of map
	BEQ	TRDO		; of so no move
	SEC
	SBC	#1		; else back one
	STA	YOFFSET	
TRDO	LDA	DOWN		; move down ?
	BEQ	NOKEY		; no

	LDA	YOFFSET
BOTTOM1	CMP	#255		;SIZEY-PLOT_Y
	BNE	SPINAGE
	LDA	CURSOR_Y
	CMP	#PLOT_Y-1
	BCC	ADDME2
	BCS	NOKEY
	
SPINAGE	LDA	CURSOR_Y
	CMP	#BOTY 		; bottom of screen
	BEQ	TILP1		; if so move map position
ADDME2	ADC	#1	
	STA	CURSOR_Y
	JMP	NOKEY
TILP1	LDA	YOFFSET
BOTTOM2	CMP	#255		;SIZEY-PLOT_Y		; at bottom
	BEQ	NOKEY
	ADC	#1
	STA	YOFFSET
NOKEY	LDA	#0
	STA	MIKE1
	LDA	CURSOR_X
	ASL	A
	ROL	MIKE1
	ASL	A
	ROL	MIKE1
	ASL	A
	ROL	MIKE1
	ASL	A
	ROL	MIKE1
	ADC	#24
	STA	X0
	LDA	MIKE1
	ADC	#0
	STA	MSB
	LDA	CURSOR_Y
	ASL	A
	ASL	A
	ASL	A
	ASL	A
	CLC
	ADC	#50
	STA	Y0

NOCHANGE	LDA	XOFFSET
	CLC
	ADC	CURSOR_X
	STA	TEMP
	LDA	YOFFSET
	CLC
	ADC	CURSOR_Y	; at cursor position
	TAY
	LDA	GMAP_L,Y
	CLC
	ADC	TEMP
	STA	MAPMEM	; save low
	LDA	GMAP_H,Y
	ADC	#0
	STA	MAPMEM+1	; save high

	JSR	NUMBERS

	LDA	SYNC
WAIT	CMP	SYNC
	BEQ	WAIT
	JSR	ALLSCREEN
	JSR	NEW_MOVE
	JMP	FOREVER

NEW_MOVE	LDA	MOVE
	BEQ	NOJOY
	STA	LAST_MOVE	
	LDY	#2
FRUITY	LDA	MOVE
	CMP	LAST_MOVE
	BNE	NOJOY
	LDA	SYNC
WAIT2	CMP	SYNC
	BEQ	WAIT2
	DEY
	BPL	FRUITY
NOJOY	RTS	

LET_KEY_GO	LDY	#8		; vsync waits to let key go
	STA	TEMP		; bit test for key
CARRY	LDA	KEYBYTE,X		; get compare
	AND	TEMP		; take out
	BNE	LEFTA
	LDA	SYNC
WAIT1	CMP	SYNC
	BEQ	WAIT1
	DEY
	BNE	CARRY
LEFTA	RTS

****************************************
*	FIRST IRQ for main	*	
****************************************
IRQ	STA	IRQSAVEA		; raster entry
	LDA	#1
	STA	VICIFR
	INC	SPC0
	IF	PDS
	STY	IRQSAVEY
	STX	IRQSAVEX
	JSR	JOYGET
	JSR	PDSMONITOR
	LDY	IRQSAVEY
	LDX	IRQSAVEX
	ENDIF
	DEC	SYNC
	LDA	#250
	STA	RASTER
	LDA	IRQSAVEA
IGNORE	RTI

	; main game IRQ setup, and NMI
SETIRQ	SEI		
	LDA	#127
	STA	CIA1ICR
	STA	CIA2ICR
	LDA	CIA1ICR
	LDA	CIA2ICR
	LDA	#>IRQ
	STA	IRQVECTOR
	LDA	#<IRQ
	STA	IRQVECTOR+1
	LDA	#>IGNORE
	STA	NMIVECTOR
	LDA	#<IGNORE
	STA	NMIVECTOR+1
	LDA	#1
	STA	VICIMR
	STA	VICIFR
	LDA	#250
	STA	RASTER
	CLI
	RTS

JOYGET	LDA	#255
	STA	CIA1+2
	LDA	#&7F
	STA	CIA1+0
	LDA	CIA1+1
	STA	KEYBYTE+7
	LDA	#&BF
	STA	CIA1+0
	LDA	CIA1+1
	STA	KEYBYTE+6
	LDA	#&DF
	STA	CIA1+0
	LDA	CIA1+1
	STA	KEYBYTE+5
	LDA	#&EF
	STA	CIA1+0
	LDA	CIA1+1
	STA	KEYBYTE+4
	LDA	#&F7
	STA	CIA1+0
	LDA	CIA1+1
	STA	KEYBYTE+3
	LDA	#&FB
	STA	CIA1+0
	LDA	CIA1+1
	STA	KEYBYTE+2
	LDA	#&FD
	STA	CIA1+0
	LDA	CIA1+1
	STA	KEYBYTE+1
	LDA	#&FE
	STA	CIA1+0
	LDA	CIA1+1
	STA	KEYBYTE+0
	
	LDA	#0
	STA	CIA1+2	; read joystick
	STA	LEFT
	STA	RIGHT
	STA	UP
	STA	DOWN
	STA	FIRE
	LDA	CIA1
	EOR	#%00011111
	STA	JOY
	AND	#%00001111	; use only direction bits
	STA	MOVE

	; 7 6 5 4 3 2 1 0
	; 0 up
	; 1 down
	; 2 left
	; 3 right
	; 4 fire
	LDA	JOY
	LSR	A
	ROL	UP
	LSR	A
	ROL	DOWN
	LSR	A
	ROL	LEFT
	LSR	A
	ROL	RIGHT
	LSR	A
	ROL	FIRE
	RTS

	; from two sets of values grab a block of data and save to temp
	; so can ladder replot whereever I need to

COPY_STARTX	DB	0
COPY_STARTY	DB	0
COPY_ENDX		DB	0
COPY_ENDY		DB	0
LENGTH_X		DB	0
LENGTH_Y		DB	255

	; call this when f1 pressed
GRAB_FIRST
	LDA	XOFFSET
	CLC
	ADC	CURSOR_X
	STA	COPY_STARTX		; first x cord
	LDA	YOFFSET
	CLC
	ADC	CURSOR_Y
	STA	COPY_STARTY
	LDA	#255
	STA	LENGTH_Y
ERROR	RTS

GRAB_SECOND	
	LDA	XOFFSET
	CLC
	ADC	CURSOR_X
	CMP	COPY_STARTX
	BCS	X_CORRECT
	LDY	COPY_STARTX		; get first x position
	STA	COPY_STARTX		; save second to first
	TYA
X_CORRECT	STA	COPY_ENDX		; save end x cord
	SEC
	SBC	COPY_STARTX
	STA	LENGTH_X

	LDA	YOFFSET
	CLC
	ADC	CURSOR_Y
	; Now sort cords to biggest
	CMP	COPY_STARTY
	BCS	Y_CORRECT
	LDY	COPY_STARTY		; get first y position
	STA	COPY_STARTY		; save second to first
	TYA
Y_CORRECT	STA	COPY_ENDY		; save first to second
	SEC
	SBC	COPY_STARTY
	STA	LENGTH_Y

	; Now copy map data to temp area for safe keeping (and replotting)
	LDY	COPY_STARTY		; get map mem
	LDA	GMAP_L,Y
	STA	MIKE2
	LDA	GMAP_H,Y
	STA	MIKE2+1
	LDX	#0		; store end
	LDA	LENGTH_Y		; y amount (can be 0 to start with)
	STA	MIKE1+1
GRAB_DATA
	LDA	LENGTH_X
	STA	MIKE1
	LDY	COPY_STARTX
LINES_WORTH
	LDA	(MIKE2),Y		; get map byte
SAVE_ME	STA	SAVE_DATA,X		; save to temp
	INX
	BNE	FRID
	INC	SAVE_ME+2
FRID	INY
	DEC	MIKE1
	BPL	LINES_WORTH	
	LDA	MIKE2
	CLC
	ADC	XSIZE		;#SIZEX		; next line down
	STA	MIKE2
	BCC	!FROG
	INC	MIKE2+1
!FROG	DEC	MIKE1+1
	BPL	GRAB_DATA	
	LDA	#<SAVE_DATA		; poke back after first grab
	STA	SAVE_ME+2	
ERROR1	RTS

	; Now copy map data to temp area for safe keeping (and replotting)
REPLOT_DATA
	LDA	LENGTH_Y
	CMP	#255
	BEQ	ERROR1	
	LDA	YOFFSET
	CLC
	ADC	CURSOR_Y
	TAY
	LDA	GMAP_L,Y
	STA	MIKE2
	LDA	GMAP_H,Y
	STA	MIKE2+1
	LDX	#0		; store end
	LDA	LENGTH_Y		; y amount (can be 0 to start with)
	STA	MIKE1+1
PLOT_DATA	LDA	LENGTH_X
	STA	MIKE1

	LDA	XOFFSET
	CLC
	ADC	CURSOR_X
	TAY
LINES_WORTH1
READ_ME	LDA	SAVE_DATA,X
	STA	(MIKE2),Y		; get map byte
	INX
	BNE	FRID1
	INC	READ_ME+2
FRID1	INY
	CPY	XSIZE		;#SIZEX
	BCC	ONSC
	TXA
	CLC
	ADC	MIKE1
	TAX
	JMP	SKIPP

ONSC	DEC	MIKE1
	BPL	LINES_WORTH1

SKIPP	LDA	MIKE2
	CLC
	ADC	XSIZE		;#SIZEX		; next line down
	STA	MIKE2
	BCC	!FROG
	INC	MIKE2+1
!FROG	DEC	MIKE1+1
	BPL	PLOT_DATA	
	LDA	#<SAVE_DATA		; poke back after first grab
	STA	READ_ME+2	
	RTS

	; POKE SCORE VALUE IN
	; SPRITE AREAS
NUMBERS	LDA	#0	; KEEP COUNT OF WHERE TO PLOT
	STA	MIKE2	; GENERAL TEMP X COUNTER
	LDA	XOFFSET
	CLC
	ADC	CURSOR_X	; get map cords in x
	STA	TILE_XPOS
	JSR	ONEB
	LDA	YOFFSET
	CLC
	ADC	CURSOR_Y	; get map cords in y
	STA	TILE_YPOS
	JSR	ONEB

	LDA	XSIZE	; physical x size
	JSR	ONEB
	LDA	YSIZE	; physical y size
	JSR	ONEB

	LDA	XOFFSET	; get memory pointer
	CLC
	ADC	CURSOR_X
	STA	MIKE2+1
	LDA	YOFFSET
	CLC
	ADC	CURSOR_Y	; at cursor position
	TAY
	LDA	GMAP_L,Y
	CLC
	ADC	MIKE2+1
	STA	SMC+1	; save low
	LDA	GMAP_H,Y
	ADC	#0
	STA	SMC+2	; save high
	JSR	ONEB
	LDA	SMC+1	; get back low
	JSR	ONEB
SMC	LDA	&FFFF	; get map byte
	JSR	ONEB
	LDA	BYTE	; to poke to map
ONEB	STA	MIKE2+1	; TEMP STORE
	LSR	A
	LSR	A
	LSR	A
	LSR	A
	JSR	NUMB	; PLOT IN HIGH NIBBLE FIRST
	LDA	MIKE2+1
	AND	#15	; NOW PLOT IN THEN LOW NIBBLE
NUMB	ASL	A	; ACTUAL VALUE * 8 FOR BASE
	ASL	A	; ADDRESS FOR EACH CHARACTER
	ASL	A	; EACH CHARACTER BEING 8 BYTES
	TAX
	LDY	MIKE2	; GET HIGHT BYTE FOR SPRITE
	LDA	ADDML,Y	; SPRITE ADDRESS LOW BYTE
	STA	MIKE1
	LDA	ADDMH,Y	; SPRITE ADDRESS HIGH BYTE
	STA	MIKE1+1
	INC	MIKE2	; INCREMENT X POINTER
	LDY	#0
	LDA	NUMBRS+0,X	; plot data in sprite pointer
	STA	(MIKE1),Y
	LDY	#1*3
	LDA	NUMBRS+1,X
	STA	(MIKE1),Y
	LDY	#2*3
	LDA	NUMBRS+2,X
	STA	(MIKE1),Y
	LDY	#3*3
	LDA	NUMBRS+3,X
	STA	(MIKE1),Y
	LDY	#4*3
	LDA	NUMBRS+4,X
	STA	(MIKE1),Y
	LDY	#5*3
	LDA	NUMBRS+5,X
	STA	(MIKE1),Y
	LDY	#6*3
	LDA	NUMBRS+6,X
	STA	(MIKE1),Y
	LDY	#7*3
	LDA	NUMBRS+7,X
	STA	(MIKE1),Y
	RTS

	; offset to next sprite at top position in them
ADDML	DL	((PSP_POINT+1)*64)+0
	DL	((PSP_POINT+1)*64)+1
	DL	((PSP_POINT+2)*64)+0
	DL	((PSP_POINT+2)*64)+1
	DL	((PSP_POINT+3)*64)+0
	DL	((PSP_POINT+3)*64)+1
	DL	((PSP_POINT+4)*64)+0
	DL	((PSP_POINT+4)*64)+1

	DL	((PSP_POINT+5)*64)+0
	DL	((PSP_POINT+5)*64)+1
	DL	((PSP_POINT+5)*64)+2
	DL	((PSP_POINT+6)*64)+0
	DL	((PSP_POINT+6)*64)+2
	DL	((PSP_POINT+7)*64)+0
	DL	((PSP_POINT+7)*64)+1
	DL	((PSP_POINT+7)*64)+2
		
ADDMH	DH	((PSP_POINT+1)*64)+0
	DH	((PSP_POINT+1)*64)+1
	DH	((PSP_POINT+2)*64)+0
	DH	((PSP_POINT+2)*64)+1
	DH	((PSP_POINT+3)*64)+0
	DH	((PSP_POINT+3)*64)+1
	DH	((PSP_POINT+4)*64)+0
	DH	((PSP_POINT+4)*64)+1

	DH	((PSP_POINT+5)*64)+0
	DH	((PSP_POINT+5)*64)+1
	DH	((PSP_POINT+5)*64)+2
	DH	((PSP_POINT+6)*64)+0
	DH	((PSP_POINT+6)*64)+2
	DH	((PSP_POINT+7)*64)+0
	DH	((PSP_POINT+7)*64)+1
	DH	((PSP_POINT+7)*64)+2

NUMBRS	HEX	3C464646467E3C00
	HEX	1010101818181800
	HEX	3C62027E70707E00
	HEX	3C46061E0E4E3C00
	HEX	1C2C4C4C7E7E0C00
	HEX	7E407C0E0E4E7E00
	HEX	3C62407E46463C00
	HEX	7E0E0C1C1C1C1C00
	HEX	3C24247E46467E00
	HEX	7E42427E06060600
	HEX	7C6464FEE2E2E200
	HEX	FCC4C4FEE2E2FE00
	HEX	7CC2C0E0E0E27C00
	HEX	FCC2C2E2E2E2FC00
	HEX	FCC0C0FCE0E0FC00
	HEX	FCC0C0FCE0E0E000

	TABLELO	SMAPL,0,11,80,SCREEN1
	TABLEHI	SMAPH,0,11,80,SCREEN1

SWAP_MAP	INC	BORDER
	LDA	#>MAP_START
	STA	MIKE1
	LDA	#>OTHER_MAP
	STA	MIKE2
	LDA	#<OTHER_MAP
	STA	MIKE1+1
	LDA	#<MAP_START
	STA	MIKE2+1
	LDY	#0
	LDX	#&1D
EXCHANGE	LDA	(MIKE1),Y
	PHA
	LDA	(MIKE2),Y
	STA	(MIKE1),Y
	PLA
	STA	(MIKE2),Y
	INY
	BNE	EXCHANGE
	INC	MIKE2+1
	INC	MIKE1+1
	DEX
	BNE	EXCHANGE
	DEC	BORDER
	RTS

CHANGE	INC	BORDER
	LDA	#<MAP_START	; high byte
	STA	MIKE1+1
	LDY	#>MAP_START	; low byte
	STY	MIKE1+0
	LDA	#&1D
	STA	MIKE2
CHANGEL	LDX	#0
GET_IT	LDA	CHANGE_TAB,X
	CMP	#255
	BEQ	END_LIST
	CMP	(MIKE1),Y		; first in block
	BEQ	MODIT
	INX
	INX
	BNE	GET_IT
MODIT	LDA	CHANGE_TAB+1,X
	STA	(MIKE1),Y
END_LIST	INY
	BNE	CHANGEL
	INC	MIKE1+1
	DEC	MIKE2
	BNE	CHANGEL
	DEC	BORDER
	RTS

CHANGE_TAB	DS	0,254
	DB	255

	IF	PDS

FLAGS	EQU	&DD00
DATA	EQU	&DD01
IN	EQU	4
OUT	EQU	8

PDSSETUP	LDA	#&3B
	STA	&DD02		;Setup flags port.
	LDA	#0
	STA	&DD03		;Data port setup for reading.
POWER	RTS

PDSMONITOR	LDA	FLAGS
	EOR	!STROBE+1
	AND	#IN		;Get the command byte.
	BNE	POWER
	LDX	DATA		;Leave command byte in X register.
	LDA	FLAGS
	AND	#255-IN-OUT
	ORA	!STROBE+1
	STA	FLAGS
	LDA	!STROBE+1
	EOR	#IN+OUT
	STA	!STROBE+1
	CPX	#179
	BEQ	PDSMONITOR
!NOT187	CPX	#180
	BNE	!NOT180
	JSR	!GETBYT
	STA	!ADDR+2		;This is the start address.
	JSR	!GETBYT
	TAY
	JSR	!GETBYT
	STA	!COUNT1+1
	JSR	!GETBYT
	STA	!COUNT0+1		;This is the length of code.
!COUNT0	LDA	#1
	BNE	!0
!COUNT1	LDA	#1
	BEQ	!5		;Decrement counter.
 	DEC	!COUNT1+1
!0	DEC	!COUNT0+1
	JSR	!GETBYT
!ADDR	STA	&100,Y		;Get and store byte.
	INY
	BNE	!COUNT0
	INC	!ADDR+2		;Inc position in memory.
	JMP	!COUNT0

!NOT180	CPX	#182
	BNE	!5
	JSR	!GETBYT
	STA	!SADDR+2		;This is the start address.
	JSR	!GETBYT
	TAY
	JSR	!GETBYT
	STA	!SCOUNT1+1
	JSR	!GETBYT
	STA	!SCOUNT0+1		;This is the length of code.
!UPLOAD	JSR	!PORTOUT		;Set up ports for output.
!SCOUNT0	LDA	#1
	BNE	!1
!SCOUNT1	LDA	#1
	BEQ	!OUT		;Decrement counter.
	DEC	!SCOUNT1+1
!1	DEC	!SCOUNT0+1
!SADDR	LDA	&100,Y		;Get and send byte.
	JSR	!SENDBYT
	INY
	BNE	!SCOUNT0
	INC	!SADDR+2		;Inc position in memory.
	JMP	!SCOUNT0
!OUT	JMP	!PORTIN		;Set up ports for input again.

!GETBYT	LDA	FLAGS
!STROBE	EOR	#8		; to start with
	AND	#IN
	BNE	!GETBYT
	LDX	DATA
	LDA	FLAGS
	AND	#255-IN-OUT
	ORA	!STROBE+1
	STA	FLAGS
	LDA	!STROBE+1
	EOR	#IN+OUT
	STA	!STROBE+1
	TXA
!5	RTS

!SENDBYT	STA	DATA
	LDA	FLAGS
	AND	#255-IN-OUT
	ORA	!STROBE+1
	STA	FLAGS
	LDA	!STROBE+1
	EOR	#IN+OUT
	STA	!STROBE+1
!2	LDA	FLAGS
	EOR	!STROBE+1
	AND	#IN
	BEQ	!2
	RTS

!PORTIN	LDA	#0
	STA	&DD03		;Data port setup for reading.
	LDA	FLAGS
	AND	#255-IN-OUT
	ORA	!STROBE+1
	STA	FLAGS
	LDA	!STROBE+1
	EOR	#OUT
	STA	!STROBE+1
	RTS

!PORTOUT	LDA	FLAGS
	EOR	!STROBE+1		;Wait till pc ready.
	AND	#IN
	BNE	!PORTOUT
	LDA	#255
	STA	&DD03		;Data ports
	LDA	!STROBE+1
	EOR	#IN		;Toggle strobe line.
	STA	!STROBE+1
	RTS

	ENDIF

C	EQU	15
	
PLOT_TILE	MACRO
	LDA	(MAP_MEM1),Y
	TAX

	LDA	TILE_TL,X		; 4
	STA	SCREEN1+@1		; 4
	LDA	TCOL_TL,X		; 4
	;LDA	#C
	STA	NYBBLE+@1		; 4

	LDA	TILE_TR,X		; 4
	STA	SCREEN1+1+@1	; 4
	LDA	TCOL_TR,X		; 4
	;LDA	#C
	STA	NYBBLE+1+@1		; 4

	LDA	TILE_BL,X		; 4
	STA	SCREEN1+40+@1	; 4
	LDA	TCOL_BL,X		; 4
	;LDA	#C
	STA	NYBBLE+40+@1	; 4

	LDA	TILE_BR,X		; 4
	STA	SCREEN1+41+@1	; 4
	LDA	TCOL_BR,X		; 4
	;LDA	#C
	STA	NYBBLE+41+@1	; 4

	ENDM

	; plot across top of screen with TINX = 0 & TINY = 0

PLOTLINE	MACRO
	LDY	YOFFSET
	LDA	XOFFSET
	CLC
	ADC	GMAP_L+@1,Y
	STA	MAP_MEM1
	LDA	GMAP_H+@1,Y
	ADC	#0
	STA	MAP_MEM1+1
	LDY	#0

	PLOT_TILE	(@1*80)+0
	INY
	PLOT_TILE	(@1*80)+2
	INY
	PLOT_TILE	(@1*80)+4
	INY
	PLOT_TILE	(@1*80)+6
	INY
	PLOT_TILE	(@1*80)+8
	INY
	PLOT_TILE	(@1*80)+10
	INY
	PLOT_TILE	(@1*80)+12
	INY
	PLOT_TILE	(@1*80)+14
	INY
	PLOT_TILE	(@1*80)+16
	INY
	PLOT_TILE	(@1*80)+18
	INY
	PLOT_TILE	(@1*80)+20
	INY
	PLOT_TILE	(@1*80)+22
	INY
	PLOT_TILE	(@1*80)+24
	INY
	PLOT_TILE	(@1*80)+26
	INY
	PLOT_TILE	(@1*80)+28
	INY
	PLOT_TILE	(@1*80)+30
	INY
	PLOT_TILE	(@1*80)+32
	INY
	PLOT_TILE	(@1*80)+34
	INY
	PLOT_TILE	(@1*80)+36
	INY
	PLOT_TILE	(@1*80)+38

	ENDM
ALLSCREEN
	PLOTLINE	0
	IF	PLOT_Y>1
	PLOTLINE	1
	ENDIF
	IF	PLOT_Y>2
	PLOTLINE	2
	ENDIF
	IF	PLOT_Y>3
	PLOTLINE	3
	ENDIF
	IF	PLOT_Y>4
	PLOTLINE	4
	ENDIF
	IF	PLOT_Y>5
	PLOTLINE	5
	ENDIF
	IF	PLOT_Y>6
	PLOTLINE	6
	ENDIF
	IF	PLOT_Y>7
	PLOTLINE	7
	ENDIF
	IF	PLOT_Y>8
	PLOTLINE	8
	ENDIF
	IF	PLOT_Y>9
	PLOTLINE	9
	ENDIF
	IF	PLOT_Y>10
	PLOTLINE	10
	ENDIF
	IF	PLOT_Y>11
	PLOTLINE	11
	ENDIF

QUIT1	RTS


OF	EQU	21*40		; down somewhere
	; show tiles at bottom of screen
SHOW_TILES	LDX	BYTE		; to poke to map
	LDY	#0
	LDA	#20
	STA	MIKE1
ALS	LDA	TILE_TL,X		; 4
	STA	SCREEN1+OF,Y	; 4
	LDA	TCOL_TL,X		; 4
	STA	NYBBLE+OF,Y		; 4
	LDA	TILE_TR,X		; 4
	STA	SCREEN1+OF+1,Y	; 4
	LDA	TCOL_TR,X		; 4
	STA	NYBBLE+OF+1,Y	; 4
	LDA	TILE_BL,X		; 4
	STA	SCREEN1+40+OF,Y	; 4
	LDA	TCOL_BL,X		; 4
	STA	NYBBLE+40+OF,Y	; 4
	LDA	TILE_BR,X		; 4
	STA	SCREEN1+41+OF,Y	; 4
	LDA	TCOL_BR,X		; 4
	STA	NYBBLE+41+OF,Y	; 4
	INY
	INY
	INX
	DEC	MIKE1
	BNE	ALS
	RTS

	; plot tunnel control bits
PLOT_CONTROL
	; plot 8 bytes to map (checking for valid positions)
	LDX	TILE_XPOS
	LDY	TILE_YPOS
	DEX
	DEX
	LDA	#&F8
	JSR	POKE_MAP
	INX
	LDA	#&FA
	JSR	POKE_MAP
	INX
	INX
	LDA	#&FB
	JSR	POKE_MAP
	INX
	LDA	#&F8
	JSR	POKE_MAP
	DEX
	DEX
	DEY
	LDA	#&FD
	JSR	POKE_MAP
	CPY	#0		; already at top
	BEQ	ATTOP
	DEY	
	LDA	#&F9
	JSR	POKE_MAP
	INY
ATTOP	INY
	INY
	INY
	CPY	SIZEY
	BEQ	LAST
	LDA	#&FC
	JSR	POKE_MAP
	INY
	LDA	#&F9
POKE_MAP	STA	HERE+1
	LDA	GMAP_L,Y
	STA	STOR_MEM+1		; save low
	LDA	GMAP_H,Y
	STA	STOR_MEM+2
HERE	LDA	#255
STOR_MEM	STA	&FFFF,X
LAST	RTS

SHOW_RESCUE
	LDY	RESCUE		; amount to save
	BEQ	LAST		; if none here
SHOW_ALL	STY	TEMP	
	LDA	TMAP_XH-1,Y
	STA	MIKE1
	LDA	TMAP_XL-1,Y
	LSR	MIKE1
	ROR	A
	LSR	MIKE1
	ROR	A
	LSR	MIKE1
	ROR	A
	LSR	MIKE1
	ROR	A
	TAX
	LDA	TMAP_YH-1,Y
	STA	MIKE1
	LDA	TMAP_YL-1,Y
	LSR	MIKE1
	ROR	A
	LSR	MIKE1
	ROR	A
	LSR	MIKE1
	ROR	A
	LSR	MIKE1
	ROR	A
	TAY
	LDA	GMAP_L,Y
	STA	!STOR_MEM+1		; save low
	LDA	GMAP_H,Y
	STA	!STOR_MEM+2
	LDA	#&7F
!STOR_MEM	STA	&FFFF,X		; save to map
	LDY	TEMP
	DEY
	BNE	SHOW_ALL
	RTS

MAKE_MAP_MEM
	; first poke to places bounds checks
	LDA	XSIZE
	SEC
	SBC	#20		; get stop position
	STA	RIGHT1+1
	STA	RIGHT2+1
	LDA	YSIZE
	SEC
	SBC	#PLOT_Y
	STA	BOTTOM1+1
	STA	BOTTOM2+1
	; map memory map for redraw
	LDX	#0		; start save
	LDA	#>MAP_START
	STA	MIKE1		; map start low
	LDA	#<MAP_START
	STA	MIKE1+1		; map start high
	
MAKE_MEM	LDA	MIKE1
	STA	GMAP_L,X		; save low
	LDA	MIKE1+1
	STA	GMAP_H,X		; save high
	CPX	YSIZE		; amount in y as count
	BCS	NOER
	LDA	MIKE1
	ADC	XSIZE
	STA	MIKE1
	BCC	NOER
	INC	MIKE1+1
NOER	INX
	CPX	#128		; only have 128 here
	BNE	MAKE_MEM
	RTS


SAVE_DATA	DS	1024,0


TOGGLE	DB	0

HIDE_CONTROL
	LDA	TOGGLE
	EOR	#1
	STA	TOGGLE
	BNE	HIDE_TUNNELS
	JMP	UNHIDE_MAP

****************************************
*	Hide total tunnel map	*
****************************************
HIDE_TUNNELS
	LDX	#0
HIDE_ALL	LDA	TXSTART,X
	CMP	#255
	BEQ	END_TAB
	STA	TEMP1		; start across
	LDA	TXSTOP,X
	STA	TEMP1+1		; stop across

	LDA	TYSTART,X
	STA	MIKE2		; start down
	LDA	TYSTOP,X
	STA	MIKE2+1		; stop down

ROMULAN	LDY	MIKE2		; downward position
	LDA	GMAP_L+0,Y
	STA	MIKE1+0
	LDA	GMAP_H+0,Y
	STA	MIKE1+1

	LDY	TEMP1		; start x
LINES_W	LDA	(MIKE1),Y		; get first part
	BEQ	SKP		; leave zero alone (must do)
	ORA	#128
	STA	(MIKE1),Y
SKP	INY
	CPY	TEMP1+1		; end of line
	BNE	LINES_W

	INC	MIKE2
	LDA	MIKE2
	CMP	MIKE2+1		; at bottom
	BNE	ROMULAN
	INX
	BNE	HIDE_ALL
END_TAB	RTS

****************************************
*	Hide/Unhihe total map	*
****************************************
UNHIDE_MAP	LDX	#&29		; AND #&7F
	LDY	#&7F
	JMP	GDOIT
HIDE_MAP	LDX	#9		; ORA #&80
	LDY	#&80
GDOIT	STX	PACTION
	STY	PACTION+1
	LDA	#<MAP_START
	STA	MIKE1+1		; high byte
	LDA	#>MAP_START
	STA	MIKE1+0		; low byte
	LDX	SIZEY		; y amount down
WHOLE_MAP	LDY	SIZEX		; no bigger then 128 as BPL used
FIRST_LIN	LDA	(MIKE1),Y		; get first part
	BEQ	NOCH1		; leave zero alone (must do)
PACTION	ORA	#128
	STA	(MIKE1),Y
NOCH1	DEY
	CPY	#255
	BNE	FIRST_LIN
	LDA	MIKE1
	CLC
	ADC	SIZEX
	STA	MIKE1
	BCC	!CARRY
	INC	MIKE1+1
!CARRY	DEX
	BPL	WHOLE_MAP
NODOORS	RTS

	; shut and open doors toggle
CLOSE_DOORS
	LDA	STORE_VAL+1
	EOR	#&74
	STA	STORE_VAL+1
	LDX	#0
SHUT_DOORS	LDY	DOOR_Y,X		; door x position
	CPY	#255		; last one in list
	BEQ	NODOORS
	STX	MIKE2
	LDA	DOOR_SIZE,X		; length of door
	STA	MIKE1
	LDA	DOOR_X,X		; door start x position
	TAX			; x now have x offset
ALL_DOOR	LDA	GMAP_L+1,Y		; map memory low
	STA	PLACE+1
	LDA	GMAP_H+1,Y		; map memory hi
	STA	PLACE+2
STORE_VAL	LDA	#0		; door there byte
PLACE	STA	&FFFF,X
	DEY			; upward from screen
	DEC	MIKE1
	BNE	ALL_DOOR
	LDX	MIKE2
	INX
	JMP	SHUT_DOORS

	; delete line down screen
DELETE_VERTICAL
	LDA	XSIZE		; screen already smallest
	CMP	#20
NODOORS1	BEQ	NODOORS
	SBC	#1
	STA	TEMP1

	LDA	#<MAP_START
	STA	MIKE1+1		; high
	STA	MIKE2+1
	LDA	#>MAP_START
	STA	MIKE1
	STA	MIKE2

	LDA	XOFFSET
	CLC
	ADC	CURSOR_X		; position in map
	STA	TEMP		; start of where to mod
	LDX	#0		; init count for y size
DEL_COLUM	LDY	#0
	LDA	TEMP
	BEQ	FIRST_BIT
NOW_LOSE	LDA	(MIKE1),Y
	STA	(MIKE2),Y
	INY
	CPY	TEMP		; position to save
	BNE	NOW_LOSE
FIRST_BIT	LDA	MIKE1
	CLC
	ADC	#1		; advance on read
	STA	MIKE1
	BCC	!CARRY
	INC	MIKE1+1
!CARRY	LDA	(MIKE1),Y
	STA	(MIKE2),Y
	INY
	CPY	TEMP1
	BNE	!CARRY
	TYA
	CLC
	ADC	MIKE1
	STA	MIKE1
	BCC	!KLINGON
	INC	MIKE1+1
!KLINGON	TYA
	CLC
	ADC	MIKE2
	STA	MIKE2
	BCC	!ROMULAN
	INC	MIKE2+1
!ROMULAN	INX
	CPX	YSIZE	
	BNE	DEL_COLUM
	DEC	XSIZE
	LDA	XOFFSET
	CMP	RIGHT1+1
	BNE	MOVE_OTH
	DEC	XOFFSET
MOVE_OTH	JMP	MAKE_MAP_MEM

	; delete line across whole line horizontaly
DELETE_HORIZONTAL	
	LDA	YSIZE
	CMP	#PLOT_Y		; smallest is screen size
	BEQ	NODOORS1		; no change
	LDA	YOFFSET
	CLC
	ADC	CURSOR_Y	; at cursor position
	TAY
	CLC
	ADC	#1
	CMP	YSIZE	; bottom of screen
	BEQ	AT_BOTTOM	; just make map one smaller
DEL_LINE	LDA	GMAP_L,Y	; store to this line
	STA	FIRST+1	; save low
	LDA	GMAP_H,Y
	STA	FIRST+2	; high
	LDA	GMAP_L+1,Y	; store to this line
	STA	READ+1	; save low
	LDA	GMAP_H+1,Y
	STA	READ+2	; high
	LDX	XSIZE
	DEX
READ	LDA	&FFFF,X
FIRST	STA	&FFFF,X
	DEX
	CPX	#255
	BNE	READ
	INY
	CPY	YSIZE	
	BNE	DEL_LINE
LOOSE_LINE	LDA	YOFFSET
	CMP	BOTTOM1+1		; largest position
	BNE	VAL_BOT
AT_BOTTOM	DEC	YOFFSET
VAL_BOT	DEC	YSIZE		; one less now
	JMP	MAKE_MAP_MEM

	; A key mask, X keytable index, Y carry on delay 50ths
DE_BOUNCE	STA	MASK+1
LET_GO_OF	LDA	KEYBYTE,X
MASK	AND	#255
	BNE	HAS_LET_GO
	LDA	SYNC
FIFTY	CMP	SYNC
	BEQ	FIFTY	
	DEY
	BNE	LET_GO_OF
HAS_LET_GO	RTS

PICK_BYTE	DB	0

	; setup pickup items to map
SET_PICKUPS
	LDA	PICK_BYTE
	EOR	#1
	STA	PICK_BYTE
	BEQ	LOOSE_PICKUPS	
	LDX	#0		; 
DO_ALLTHEM	LDA	PICKUP_Y,X		; new position
	CMP	#255		; last on in list
	BEQ	ENDLIST
	TAY
	LDA	GMAP_L,Y
	STA	MAP_MEM0		; low
	LDA	GMAP_H,Y
	STA	MAP_MEM0+1		; high
	LDA	PICKUP_X,X		; x position in line
	TAY
	LDA	(MAP_MEM0),Y	; get map byte
	STA	PICKUP_OLD,X	; save this byte
	LDA	PICKUP_NEW,X	; place item there
	CLC
	ADC	#&78		; start of pickups tiles
	STA	(MAP_MEM0),Y	; save to map
	INX			; next on list
	JMP	DO_ALLTHEM
ENDLIST	RTS

LOOSE_PICKUPS
	LDX	#0
LOOSE_PICK	LDA	PICKUP_Y,X		; new position
	CMP	#255		; last on in list
	BEQ	ENDLIST
	TAY
	LDA	GMAP_L,Y
	STA	MAP_MEM0		; low
	LDA	GMAP_H,Y
	STA	MAP_MEM0+1		; high
	LDA	PICKUP_X,X		; x position in line
	TAY
	LDA	PICKUP_OLD,X	; place item there
	STA	(MAP_MEM0),Y	; save to map
	INX			; next on list
	JMP	LOOSE_PICK

	ORG	&5080		; map moved
OTHER_MAP
	IF	LEVEL=0
	INCBIN	..\LEVEL\TUNNELS\1A.MAP	; original map
	ENDIF
	IF	LEVEL=1
	INCBIN	..\LEVEL\TUNNELS\1B.MAP	; original map
	ENDIF
	IF	LEVEL=3
	INCBIN	..\LEVEL\TUNNELS\2A.MAP	; original map
	ENDIF
	IF	LEVEL=4
	INCBIN	..\LEVEL\TUNNELS\2B.MAP	; original map
	ENDIF
	IF	LEVEL=5
	INCBIN	..\LEVEL\TUNNELS\2C.MAP	; original map
	ENDIF
	IF	LEVEL=7
	INCBIN	..\LEVEL\TUNNELS\3A.MAP	; original map
	ENDIF
	IF	LEVEL=8
	INCBIN	..\LEVEL\TUNNELS\3B.MAP	; original map
	ENDIF
	IF	LEVEL=9
	INCBIN	..\LEVEL\TUNNELS\3C.MAP	; original map
	ENDIF
	IF	LEVEL=11
	INCBIN	..\LEVEL\TUNNELS\4A.MAP	; original map
	ENDIF
	IF	LEVEL=12
	INCBIN	..\LEVEL\TUNNELS\4B.MAP	; original map
	ENDIF
	IF	LEVEL=13
	INCBIN	..\LEVEL\TUNNELS\4C.MAP	; original map
	ENDIF
	IF	LEVEL=15
	INCBIN	..\LEVEL\TUNNELS\5.MAP	; original map
	ENDIF

	SEND	COMPUTER1
	END	START_CODE


